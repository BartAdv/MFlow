13c13,14
<              -XTypeOperators
---
>              -XTypeOperators
>              -XOverloadedStrings
151c152
< Widget(..), FormLet(..), 
---
> Widget(..), FormLet(..),
158c159
< ,getCurrentUser,getUserSimple, getUser, userFormLine, userLogin, userWidget,
---
> ,getCurrentUser, getUser, userFormLine, userLogin, userWidget,
167c168
< validate, noWidget, waction,
---
> validate, noWidget,
171c172
< (<+>),wintersperse,(|*>),(|+|), (**>),(<**),wconcat,(<|>),(<*),(<$>),(<*>),
---
> (<+>),(|*>),(|+|), (**>),(<**),wconcat,(<|>),(<*),(<$>),(<*>),
177c178
< ,runFlow,MFlow.Forms.step, goingBack,backPointReturn -- , MFlow.Forms.stepDebug,
---
> ,runFlow,MFlow.Forms.step, goingBack -- , MFlow.Forms.stepDebug
191c192
< import Data.ByteString.Lazy.Char8(ByteString,pack,unpack)
---
> import Data.ByteString.Lazy.Char8(ByteString,pack,unpack,append)
201d201
< import Control.Monad.Identity
204c204
< import Data.IORef
---
> 
206,207c206
< import System.IO.Unsafe
< import Data.Char(isNumber)
---
> import System.IO.Unsafe
381,382c380,381
< type  WState view m = StateT (MFlowState view) m
< type FlowM view m=  BackT (WState view m)
---
> type  WState  m = StateT MFlowState  m
> type FlowM  m=  BackT (WState  m)
384c383
< data FormElm view a = FormElm [view] (Maybe a) deriving Typeable
---
> data FormElm view a = FormElm  [view] (Maybe a) deriving Typeable
386c385
< newtype View v m a = View { runView :: WState v m (FormElm v a) }
---
> newtype View v m a = View { runView :: WState m (FormElm v a) }
389,390c388,389
< instance (FormInput v, Monoid v,Serialize a)
<    => Serialize (a,MFlowState v) where
---
> instance (Serialize a)
>    => Serialize (a,MFlowState ) where
403c402
<   fmap f (FormElm form x)= FormElm form (fmap f x)
---
>   fmap f (FormElm  form x)= FormElm  form (fmap f x)
412,414c411,413
<                    f >>= \(FormElm form1 k) ->
<                    g >>= \(FormElm form2 x) ->
<                    return $ FormElm (form1 ++ form2) (k <*> x) 
---
>                    f >>= \(FormElm  form1 k) ->
>                    g >>= \(FormElm  form2 x) ->
>                    return $ FormElm  (form1 ++ form2) (k <*> x) 
417c416
<   empty= View $ return $ FormElm [] Nothing
---
>   empty= View $ return $ FormElm  [] Nothing
419,422c418,431
<                    f  >>= \(FormElm form1 k) ->
<                    g  >>= \(FormElm form2 x) ->
<                    return $ FormElm (form1 ++ form2) (k <|> x)
< 
---
>                    f  >>= \(FormElm  form1 k) ->
>                    g  >>= \(FormElm  form2 x) ->
>                    return $ FormElm  (form1 ++ form2) (k <|> x)
> 
> 
> instance  (Monad m, Functor m) => Monad (View view m) where
>   --View view m a-> (a -> View view m b) -> View view m b
>     View x >>= f = View $ do
>                    FormElm  form1 mk <- x
>                    case mk of
>                      Just k  -> do
>                        FormElm  form2 mk <- runView $ f k
>                        return $ FormElm (form1++ form2) mk
>                      Nothing -> return $ FormElm form1 Nothing
424,434c433
< --instance  (Monad m, Functor m) => Monad (View view m) where
< --  --View view m a-> (a -> View view m b) -> View view m b
< --    View x >>= f = View $ do
< --                   FormElm form1 mk <- x
< --                   case mk of
< --                     Just k  -> do
< --                       FormElm form2 mk <- runView $ f k
< --                       return $ FormElm (form1++ form2) mk
< --                     Nothing -> return $ FormElm form1 Nothing
< --
< --    return= View .  return . FormElm  [] . Just 
---
>     return= View .  return . FormElm   [] . Just 
437c436
<   lift f = View $   lift  f >>= \x ->  return $ FormElm [] $ Just x
---
>   lift f = View $   lift  f >>= \x ->  return $ FormElm  [] $ Just x
439,444c438,443
< --instance  (Functor m, Monad m)=> MonadState (MFlowState view) (View view m) where
< --  get = View $  get >>= \x ->  return $ FormElm [] $ Just x
< --  put st = View $  put st >>= \x ->  return $ FormElm [] $ Just x
< --
< --instance (MonadIO m, Functor m) => MonadIO (View view m) where
< --    liftIO= lift . liftIO
---
> instance  (Functor m, Monad m)=> MonadState MFlowState (View view m) where
>   get = View $  get >>= \x ->  return $ FormElm  [] $ Just x
>   put st = View $  put st >>= \x ->  return $ FormElm  [] $ Just x
> 
> instance (MonadIO m, Functor m) => MonadIO (View view m) where
>     liftIO= lift . liftIO
458,459c457
< 
< cachedWidget ::(Show a,MonadIO m,Typeable view,  Monoid view
---
> cachedWidget ::(Show a,MonadIO m,Typeable view, Monoid view
461c459
<         => String -> Int -> View view Identity a  -> View view m a
---
>         => String -> Int -> View view m a  -> View view m a
463,468c461,464
<         let(FormElm  form _, seq)= execute $ cachedByKey key 0 $ proc mf s{mfCached=True}
<         let(FormElm  _ mx2, s2)  = execute $ runStateT  (runView mf)    s{mfSequence= seq,mfCached=True} --  !> ("mfSequence s1="++  show(mfSequence s1)) !> ("mfSequence s="++  show(mfSequence s)) !> ("mfSequence s'="++  show(mfSequence s'))
<         let s''=  s{validated = validated s2}
<         return (FormElm form mx2, s'') !> ("isJust=" ++ show (isJust mx2))
<         where
<         proc mf s= runStateT (runView mf) s>>= \(r,_) -> return (r,mfSequence s)
---
>         let(FormElm  form _, s')     = execute $ cachedByKey key 0 (runStateT  (runView mf) $  s)
>         let(FormElm  _ mx2, _) = execute $  runStateT  (runView mf)   s'
> 
>         return (FormElm form mx2, s)
485c481
<    wrender :: a -> WState view m [view]
---
>    wrender :: a -> WState  m [view]
487c483
<          (FormElm frm (_ :: Maybe b)) <-  runView (widget x)
---
>          (FormElm  frm (_ :: Maybe b)) <-  runView (widget x)
489c485
<    wget :: a -> WState view m (Maybe b)
---
>    wget :: a -> WState  m (Maybe b)
503,504c499,500
< runFlow :: (FormInput view, Monoid view, Monad m)
<         => FlowM view m () -> Token -> m ()
---
> runFlow ::   Monad m  =>
>            FlowM  m () -> Token -> m ()
512,515c508
<   :: (Serialize a,
<       Typeable view,
<       FormInput view,
<       Monoid view,
---
>   :: (Serialize a,
518,519c511,512
<       FlowM view m a
<       -> FlowM view (Workflow m) a
---
>       FlowM  m a
>       -> FlowM  (Workflow m) a
555,574d547
< 
< getParam1 :: (Monad m, MonadState (MFlowState v) m, Typeable a, Read a, FormInput v)
<           => String -> Params -> [v] ->  m (FormElm v a)
< getParam1 str req form=  r
<  where
<  r= case lookup str req of
<     Just x -> maybeRead x
<     Nothing  -> return $ FormElm form Nothing
<  getType ::  m (FormElm v a) -> a
<  getType= undefined
<  x= getType r
<  maybeRead str=
<    if typeOf x == (typeOf  "")
<          then return . FormElm form . Just  $ unsafeCoerce str
<          else case readsPrec 0 str of
<               [(x,"")] ->  return . FormElm form  $ Just x
<               _ -> do
<                    modify $ \s -> s{validated= True}
<                    let err= inred . fromString $ "can't read \""++str++"\" as type " ++ show (typeOf x)
<                    return $ FormElm  (err:form) Nothing
578c551
< -- getOdd= getInt Nothing `validate` (\x-> return $ if mod x 2==0 then  Nothing else Just "only odd numbers, please")
---
> -- getOdd= getInt Nothing `validate` (\x-> return $ if mod x 2==0 then  Nothing else Just "only odd number please")
582c555
<      -> (a -> WState view m (Maybe String))
---
>      -> (a -> WState  m (Maybe String))
596,619d568
< 
< -- | Actions are callbacks that are executed when a widget is validated.
< --
< -- it returns a void widget that can be ignored with '<**' and '**>'
< --
< waction
<   :: (FormInput view, Monad m) =>
<      View view m a
<      -> (a -> FlowM view m ())
<      -> View view m ()
< waction formt act= View $ do
<    FormElm form mx <- (runView  formt) 
<    case mx of
<     Just x -> do
<       modify (\s -> s{validated= True})
<       clearEnv
<       r <- runBackT $ act x
<       case r of
<        GoBack -> do
<                modify (\s -> s{validated= False})
<                return $ FormElm form Nothing
<        _ ->  return . FormElm form $ Just ()
<         
<     _ -> return $ FormElm form Nothing
660,673c609,627
< getRadioActive :: (FormInput view, Functor m, MonadIO m) =>
<              String -> String -> View view m  String
< getRadioActive  n v= View $ do
<   st <- get
<   put st{needForm= True}
<   let env =  mfEnv st
<   FormElm form mn <- getParam1 n env []
<   return $ FormElm [finput n "radio" v
<           ( isJust mn  && v== fromJust mn) (Just "this.form.submit()")]
<           mn
< 
<        
< 
< 
---
> getParam1 :: (FormInput v,Monad m, MonadState MFlowState  m, Typeable a, Read a)
>           => String -> Params -> [v] ->  m (FormElm v a)
> getParam1 str req form=  r
>  where
>  r= case lookup str req of
>     Just x -> maybeRead x
>     Nothing  -> return $ FormElm form Nothing
>  getType ::  m (FormElm v a) -> a
>  getType= undefined
>  x= getType r
>  maybeRead str=
>    if typeOf x == (typeOf  (undefined :: String))
>          then return . FormElm form . Just  $ unsafeCoerce str
>          else case readsPrec 0 str of
>               [(x,"")] ->  return . FormElm form  $ Just x
>               _ -> do
>                    modify $ \s -> s{validated= True}
>                    let err= inred . fromString $ "can't read \""++str++"\" as type " ++ show (typeOf x)
>                    return $ FormElm  (err:form) Nothing
675,685d628
< getRadio :: (FormInput view, Functor m, MonadIO m) =>
<             String -> String -> View view m  String
< getRadio n v= View $ do
<   st <- get
<   put st{needForm= True}
<   let env =  mfEnv st
<   FormElm f mn <- getParam1 n env []
<   return $ FormElm
<       (f++[finput n "radio" v
<           ( isJust mn  && v== fromJust mn) Nothing])
<       mn
688c631
< getEnv ::  MonadState (MFlowState view) m => String -> m(Maybe String)
---
> getEnv ::  MonadState MFlowState m => String -> m(Maybe String)
714c657
<            Just v   -> if typeOf v==typeOf "" then unsafeCoerce v else show v
---
>            Just v   -> if typeOf v==typeOf (undefined ::String) then unsafeCoerce v else show v
719a663,664
> 
> 
722c667
< getNewName :: MonadState (MFlowState view) m =>  m String
---
> getNewName :: MonadState MFlowState m =>  m String
726,728c671,672
<       put $ st{mfSequence= n+1}
<       let prefix= if mfCached st then "c" else "p"
<       return $  prefix ++ show n
---
>       put $ st{mfSequence= n+1}
>       return $  "p" ++ show n
730a675,686
> getRadioActive :: (FormInput view,Functor m, MonadIO m) =>
>              String -> String -> View view m  String
> getRadioActive  n v= View $ do
>   st <- get
>   put st{needForm= True}
>   let env =  mfEnv st
>   FormElm f mn <- getParam1 n env []
>   return $ FormElm (f++[finput n "radio" v
>           ( isJust mn  && v== fromJust mn) (Just "this.form.submit()")])
>           mn
> 
>        
731a688
> 
732a690,703
> getRadio :: (FormInput view, Functor m, MonadIO m) =>
>             String -> String -> View view m  String
> getRadio n v= View $ do
>   st <- get
>   put st{needForm= True}
>   let env =  mfEnv st
>   FormElm f mn <- getParam1 n env []
>   return $ FormElm
>       (f++[finput n "radio" v
>           ( isJust mn  && v== fromJust mn) Nothing])
>       mn
> 
> 
> 
784c755
< (<<<) :: (Monad m,  Monoid view)
---
> (<<<) :: (Monad m,  Monoid view,ToByteString view)
787c758
<          -> View view m a
---
>          -> View ByteString m a
790c761
<   return $ FormElm [v $ mconcat f] mx
---
>   return $ FormElm [toByteString $ v $ mconcat f] mx
808c779
< -- @ normalize <H1> hi in HSP </H1>  ++> normalize getString
---
> -- @ toByteString <H1> hi in HSP </H1>  ++> normalize (getString $ Just "hi")
816a788,790
> class Convert a b where
>   convert :: a -> b
> 
819a794,796
> instance  ToByteString a => Convert a ByteString  where
>    convert= toByteString
> 
821a799,808
> 
> instance ToByteString ByteString where
>   toByteString= id
> 
> (<<) :: (Convert view1 view) => (view -> view) -> view1 -> view
> (<<) w x= w $ convert x
> 
> tag t v= "<" `append` t `append` ">" `append` v `append`"</"`append` t `append` ">"
> html v= tag "html" v
> body v= tag "body" v
826c813
< (<++) :: (Monad m)
---
> (<++) :: (Monad m,ToByteString v)
829c816
<       -> View v m a 
---
>       -> View ByteString m a 
832c819
<   return $ FormElm ( f ++ [ v]) mx 
---
>   return $ FormElm  (map toByteString ( f ++ [ v])) mx 
842,843c829,830
< (++>) :: (Monad m,  Monoid view)
<        => view -> View view m a -> View view m a
---
> (++>) :: (Monad m,  Monoid view,ToByteString view)
>        => view -> View view m a -> View ByteString m a
872a860,863
> 
> 
> 
> 
895c886
< data MFlowState view= MFlowState{   
---
> data MFlowState = MFlowState{   
897d887
<    mfCached  :: Bool,
915c905
<    mfHeader ::  view -> view,
---
>    mfHeader ::  ByteString -> ByteString,
927,928c917,918
< mFlowState0 :: (FormInput view, Monoid view) => MFlowState view
< mFlowState0= MFlowState 0 False [] True  False  (Lang "en") [] False False (error "token of mFlowState0 used") 0 0 [] stdHeader False
---
> mFlowState0 ::  MFlowState 
> mFlowState0= MFlowState 0 [] True  False  (Lang "en") [] False False (error "token of mFlowState0 used") 0 0 [] stdHeader False
930c920
< setHeader :: Monad m => (view -> view) -> FlowM view m ()
---
> setHeader :: (Monad m) => (ByteString -> ByteString) -> FlowM  m ()
936,940c926,930
< setCookie :: MonadState (MFlowState view) m
<           => String  -- ^ name
<           -> String  -- ^ value
<           -> String  -- ^ path
<           -> Maybe Integer   -- ^ Max-Age in seconds. Nothing for a session cookie
---
> setCookie :: MonadState MFlowState m
>           => String         -- ^ name
>           -> String         -- ^ value
>           -> String         -- ^ path
>           -> Maybe String   -- ^ Max-Age in seconds
943c933
<     modify $ \st -> st{mfCookies=  (n,v,p,fmap show me):mfCookies st }
---
>     modify $ \st -> st{mfCookies=  (n,v,p,me):mfCookies st }
945c935
< setTimeouts :: Monad m => Int -> Integer -> FlowM view m ()
---
> setTimeouts :: Monad m => Int -> Integer -> FlowM  m ()
951c941
< getWFName ::   MonadState (MFlowState view) m =>   m String
---
> getWFName ::   MonadState MFlowState  m =>   m String
956c946
< getCurrentUser ::  MonadState (MFlowState view) m=>  m String
---
> getCurrentUser ::  MonadState MFlowState  m=>  m String
969,970c959,960
< userFormLine :: (FormInput view, Monoid view, Functor m, Monad m)
<             => View view m (Maybe(Maybe User, Maybe String), Maybe String)
---
> userFormLine :: (Functor m, Monad m)
>             => View ByteString m (Maybe(Maybe User, Maybe String), Maybe String)
975c965
<              <+> fromString "  password again" ++> getPassword  <! [("size","5")]
---
>              <+>  "  password again" ++> getPassword  <! [("size","5")]
979,980c969,970
< userLogin :: (FormInput view, Monoid view, Functor m, Monad m)
<             => View view m (Maybe(Maybe User, Maybe String), Maybe String)
---
> userLogin :: ( Functor m, Monad m)
>             => View ByteString  m (Maybe(Maybe User, Maybe String), Maybe String)
982c972
<        ((User <$> fromString "Enter User: " ++> getString Nothing     <! [("size","4")]
---
>        ((User <$>  "Enter User: " ++> getString Nothing     <! [("size","4")]
997c987
< isLogged :: MonadState (MFlowState v) m => m Bool
---
> isLogged :: MonadState MFlowState m => m Bool
1000c990
<    return . not $ rus ==  anonymous
---
>    return $ rus ==  anonymous
1006,1011c996,1000
<           , FormInput view, Monoid view )
<          => Maybe String
<          -> View view m (Maybe(Maybe User, Maybe String), Maybe String)
<          -> View view m String
< userWidget muser formuser= View $ do
<    FormElm form mus <- runView $ wform formuser `validate` val muser
---
>                   , FormInput view, Monoid view )
>                  => Maybe String
>                  -> View view m (Maybe(Maybe User, Maybe String), Maybe String)
>                  -> View view m String
> userWidget muser formuser= View $ do
1014c1003
<      False -> getUser1w form mus muser $ Just rus
---
>      False -> getUser1w muser $ Just rus
1017c1006
<        getUser1w form mus muser $ lookup cookieuser  env
---
>        getUser1w muser $ lookup cookieuser  env
1021c1010
<    getUser1w form mus mu (Just usname)=
---
>    getUser1w mu (Just usname)=
1024,1026c1013
<         else getUser1w form mus Nothing Nothing
< 
<    getUser1w form mus mu Nothing= do
---
>         else getUser1w Nothing Nothing
1027a1015,1016
>    getUser1w mu Nothing= do
>       FormElm form mus <- runView $ wform  formuser `validate` val mu
1064,1065d1052
<          liftIO $ deleteTokenInList t
<          liftIO $ addTokenToList t'
1071,1076c1058,1061
< -- | if not logged, perform login. otherwise return the user
< getUserSimple :: ( FormInput view, Monoid view, Typeable view
<                  , ToHttpData view
<                  , MonadIO m, Functor m)
<               => FlowM view m String
< getUserSimple= getUser Nothing userFormLine
---
> ---- | if not logged, perform login. otherwise return the user
> --getUserSimple :: ( MonadIO m, Functor m)
> --              => FlowM  m String
> --getUserSimple= getUser Nothing . normalize $ userFormLine
1083c1068
< getUser :: ( FormInput view, Monoid view, Typeable view
---
> getUser :: ( FormInput view,ToByteString view, Monoid view, Typeable view
1088c1073
<           -> FlowM view m String
---
>           -> FlowM  m String
1094c1079
<     widget  =  id 
---
>     widget x = get >>= \st -> id x !> show (mfSequence st)
1101,1104c1086,1089
< (<+>) , mix ::  ( FormInput view , Monad m)
<       => View view m a'
<       -> View view m b'
<       -> View view m (Maybe a', Maybe b')
---
> (<+>) , mix ::  (ToByteString view1, ToByteString view2, Monad m)
>       => View view1 m a'
>       -> View view2 m b'
>       -> View ByteString m (Maybe a', Maybe b')
1108c1093
<   return $ FormElm (f1++f2) 
---
>   return $ FormElm ( map toByteString f1++map toByteString f2) 
1123,1125c1108,1110
< (**>) :: (Functor m, Monad m)
<       => View view m a -> View view m b -> View view m b
< (**>) form1 form2 = valid form1 *> form2
---
> (**>) :: (ToByteString v1,ToByteString v2,Functor m, Monad m)
>       => View v1 m a -> View v2 m b -> View ByteString m b
> (**>) form1 form2 = normalize(valid form1) *> normalize form2
1133,1135c1118,1120
<   :: (Functor m, Monad m) =>
<      View view m a -> View view m b -> View view m a
< (<**) form1 form2 =  form1 <* valid form2
---
>   :: (ToByteString v1,ToByteString v2, Functor m, Monad m) =>
>      View v1 m a -> View v2 m b -> View ByteString m a
> (<**) form1 form2 =  normalize form1 <* normalize (valid form2)
1150c1135
<   :: (Widget a b  m view,
---
>   :: (
1151a1137
>       ToByteString view,
1154c1140
<       Monad m,
---
>       MonadIO m,
1156c1142
<       a -> FlowM view m b
---
>       View view m b -> FlowM m b
1161,1162c1147,1148
<      FormElm forms mx <- lift . runView $ widget x  -- !> "runWidget"
<      st' <- mx `seq` get
---
>      FormElm forms mx <- lift $ runView x  -- !> "runWidget"
>      st' <- get
1165,1166c1151,1152
<          put st'{prevSeq= mfSequence st: prevSeq st',onInit= True,mfEnv=[]}
<          backPointReturn x                                 -- !> "just x"
---
>              put st'{prevSeq= mfSequence st: prevSeq st',onInit= True}
>              backPointReturn x                                 -- !> "just x"
1169c1155
<          if  not (validated st') && not (onInit st') && hasParams (mfSequence st') ( mfEnv st')  -- !> (show $ validated st')  !> (show $ onInit st')
---
>          if  not (validated st') && not (onInit st')   -- !> (show $ validated st')  !> (show $ onInit st')
1171,1173c1157,1159
<              put st'{mfSequence= head1 $ prevSeq st'
<                     ,prevSeq= tail1 $ prevSeq st' }
<              fail ""                           !> "repeatPlease"
---
>              put st'{mfSequence= head $ prevSeq st'
>                     ,prevSeq= tail $ prevSeq st' }
>              fail ""                           !> "repeatPlease 1"
1176c1162
<                  t= mfToken st'
---
>                  t= mfToken st
1178,1179c1164,1165
<                    (True, False) ->  header $ formAction (twfname t) $ mconcat forms
<                    _             ->  header $ mconcat  forms
---
>                    (True, False) ->  header $ toByteString $ formAction (twfname t) $ mconcat forms
>                    _             ->  header $ toByteString $ mconcat  forms
1183c1169
<              put st{mfCookies=[], onInit= False, mfToken= t }                --    !> ("after "++show ( mfSequence st'))
---
>              put st{mfCookies=[], onInit= False }                --    !> ("after "++show ( mfSequence st'))
1186,1196d1171
<     where
<     head1 []=0
<     head1 xs= head xs
<     tail1 []=[]
<     tail1 xs= tail xs
< 
<     hasParams seq= not . null . filter (\(p,_) ->
<        let tailp = tail p in
<        (head p== 'p' || head p == 'c')
<        && and (map isNumber tailp)
<        && read (tailp) <= seq)
1200c1175
< goingBack :: MonadState (MFlowState view) m => m Bool
---
> goingBack :: MonadState MFlowState m => m Bool
1206c1181
< clearEnv :: MonadState (MFlowState view) m =>  m ()
---
> clearEnv :: Monad m => FlowM  m ()
1211c1186
< receiveWithTimeouts :: MonadIO m => FlowM view m ()
---
> receiveWithTimeouts :: MonadIO m => FlowM  m ()
1261c1236
<           showx= if typeOf x== typeOf "" then unsafeCoerce x else show x
---
>           showx= if typeOf x== typeOf (undefined :: String) then unsafeCoerce x else show x
1268,1278c1243,1244
< --instance (Widget a b m view, Monoid view) => Widget [a] b m view where
< --  widget xs = View $ do
< --      forms <- mapM(\x -> (runView  $  widget x )) xs
< --      let vs  = concatMap (\(FormElm v _) -> v) forms
< --          res = filter isJust $ map (\(FormElm _ r) -> r) forms
< --          res1= if null res then Nothing else head res
< --      return $ FormElm [mconcat vs] res1
< 
< -- | concat a list of widgets of the same type, to return a single result
< wconcat :: (Monoid view, MonadIO m, Functor m)=> [View view m a]  -> View view m a
< wconcat xs= View $ do 
---
> instance Widget a b m view => Widget [a] b m view where
>   widget xs = View $ do
1280c1246
<       let vs  = concatMap (\(FormElm v _) ->  [mconcat v]) forms
---
>       let vs  = concatMap (\(FormElm v _) -> v) forms
1283c1249,1253
<       return $ FormElm  vs res1
---
>       return $ FormElm vs res1
> 
> -- | concat a list of widgets of the same type, to return a single result
> wconcat :: (MonadIO m, Functor m)=> [View view m a]  -> View view m a
> wconcat xs= widget xs
1291c1261
<   FormElm fxs rxs <-  runView $ wconcat  xs
---
>   FormElm fxs rxs <-  runView $ widget  xs
